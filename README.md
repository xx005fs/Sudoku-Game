# Sudoku-Game
A Java console programme that is a game of Sudoku. The user would try to solve the Sudoku and if they can't solve it they could give up and the computer will give the user solution.
# Introduction
This mini programme is a Sudoku mini game as the title describes. The game is composed with 2 different files and each file have different functionalities. The main.java file is where the actual game logic belongs and the sudoku.java file is where all the solver, generate, add and delete number and other functionalities that is necessary for the game to function. This was originally a school project that is meant to solve easy Sudokus by using brute force algorithm without backtracking, which just uses pure brute force by guessing all combination possible in a Sudoku. But I decided to make it faster and better (somewhat because the brute force solver might be able to solve really hard Sudokus but it will take a really long time for the computer to process), so I decided to use the logic human brain would use to solve a Sudoku instead of just pure guess and check. I also made this programme stoppable when it sees a Sudoku that is way too difficult to be solvable which will be explained later in the description.
# The Logic
This programme has 4 preset difficulty and the corresponding board: easy, medium, hard and expert. The board are already defined, however, I don't know how to generate a Sudoku according to difficulty yet so I haven't implemented that yet. 

When the user starts the programme, the user will be prompted to choose a difficulty, and if a selection is invalid then the user will be forced to try again. After the difficulty is chosen, the user can start filling in the board by choosing the 'fill in a value' option. Then the user will be prompted to type in the location which is the format of a letter followed by a number that is valid. The letter and number will be displayed on the edge of the board of the Sudoku on the command prompt window and the user will be able to tell the letter and the number that the tile is located at. After that the user will be prompted to type in the value, and the machine will make sure that the user won't fill in a value that is already present in this certain block's row, column and cell. If everything is successful, then the user can proceed to either choose to undo the last move, keep filling the value, or if the user feels that it is too hard, it would choose the 'I give up' option and the computer would solve the Sudoku by itself and then display the solved Sudoku board to the user.

If the user decided to choose the 'Undo last move' option, the machine would remove the last value that the user has filled in. If the user kept on choosing the same option, then the machine will keep removing the number that the user has filled in, until that there is no number to be removable. This is achieved by storing an arraylist of all the blocks' location that the user has filled in, then using the location to figure out which block to write zero on it, which will appear blank on the board. 

Throughout the entire game, the original board is not changed, all the changes happen in the usrboard Sudoku board. This is because if the user is filling the value and it alters the original board, then the computer wouldn't be able to figure out which block is removable and which one is not. If the user accidentally removed a default block that is not supposed to be removable, that could drastically change the outcome of the game and maybe even making the computer unable to solve it. With the user being able to get a different answer if they alter the original board, this should be totally avoided.
# The Solver Algorithm
### WARNING!!! This solver is not the final solver, it can only solve relatively easy Sudoku with only 1 solution possible!!!!!!
The solver plays a crucial role in the game, it will give the user solution really quickly whenever they give up on trying to solve the puzzle. 

First, there are several helper methods to assist the solver to be able to solve the puzzle. The helper methods helps to analyze the entire Sudoku and put all the possible values into a single matrix. 

The first helper method is analyzeRow(), which analyze a specific row to find which numbers can be filled in. The number that is able to fill in will be located at the index that is represented by the number - 1, and then stored into a 2D array that store all the information of every row of what can be filled in. Same thing applies for analyzeCol() but instead all the rows are replaced by columns and columns are replaced by rows. The third method, analyzeCell() is a little different, it basically does the exact same thing but instead of using a 2D array it uses a 3D array that is 3x3x9. It ultimately does the same thing than the previous methods.

There is a helper method called findValue() that finds the only value that could be present in a certain block. For example, in the cell a list of numbers are already filled and the same applies with a column and a row, and there is ONLY one possible value left that could be filled in, the method will return that certain and only value that will be filled in at that certain block's location. 

Another helper method that is absolutely necessary is findBlock(). This method takes a certain number and figure out a certain block within the row, column, and cell that this number could ONLY be occurring. It achieves this by looking at the empty blocks left in a row, column, or cell, then with a certain input value it figures out where the block is going to be located and then returns the index of the block within that row, column, or cell and thus figuring out where the location of that block is going to be.

Finally, the solve() methods combines everything on top and uses them, everytime when a new block is filled in with a number, the solver uses a method called updateAnalyzed(), which puts in the number and reuse the methods of analyzeRow(), analyzeCol(), analyzeCell() to analyze the entire board again, and everytime when it puts in a new number in an empty block, the same action repeats. There is a separate portion of the solver that detects whether the board is being analyzed or not. The unProcCell, unProcRow, and unProcCol are essentially counters that determines how many times the rows and columns have been updated. If the board is filled in with a value, the unProcRow, cell and col doesn't change at all, however, if a block is not being filled in a value, then unProcCell, row and col will be added by 1. If the counters have an amount of 9, means that the Sudoku solver is unable to find more solution and thus not updating the board more, the solver quits and returns false suggesting that the solver couldn't successfully solve the code. This solver will be improved in the future and there will be a separate dedicated Sudoku solver programme that is derived from this project. 

# Other Minor Details
There are numerous other helper methods that helps the game to function. For example, I overwritten the toString() method which makes the computer be able to display the board of Sudoku from a 2D array of a size of 9x9 filled with numbers, which will make it significantly more intuitive for a user to play the game as they can see what the board looks like everytime they make a move or undo a move, as well as seeing the board and analyzing it to determine where to fill the value.
