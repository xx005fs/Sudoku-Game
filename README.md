# Sudoku-Game
A Java console programme that is a game of Sudoku. The user would try to solve the Sudoku and if they can't solve it they could give up and the computer will give the user solution.
# Introduction
This mini programme is a Sudoku mini game as the title describes. The game is composed with 2 different files and each file have different functionalities. The main.java file is where the actual game logic belongs and the sudoku.java file is where all the solver, generate, add and delete number and other functionalities that is necessary for the game to function.
# The Logic
This programme has 4 preset difficulty and the corrisponding board: easy, medium, hard and expert. The board are already defined, however, I don't know how to generate a Sudoku according to difficulty yet so I haven't implemented that yet. 

When the user starts the programme, the user will be prompted to choose a difficulty, and if a selection is invalid then the user will be forced to try again. After the difficulty is chosen, the user can start filling in the board by choosing the 'fill in a value' option. Then the user will be prompted to type in the location which is the format of a letter followed by a number that is valid. The letter and number will be displayed on the edge of the board of the Sudoku on the command prompt window and the user will be able to tell the letter and the number that the tile is located at. After that the user will be prompted to type in the value, and the machine will make sure that the user won't fill in a value that is already present in this certain block's row, column and cell. If everything is successfull, then the user can proceed to either choose to undo the last move, keep filling the value, or if the user feels that it is too hard, it would choose the 'I give up' option and the computer would solve the Sudoku by itself and then display the solved Sudoku board to the user.

If the user decided to choose the 'Undo last move' option, the machine would remove the last value that the user has filled in. If the user kept on choosing the same option, then the machine will keep removing the number that the user has filled in, until that there is no number to be removeable. This is achieved by storing an arraylist of all the blocks' location that the user has filled in, then using the location to figure out which block to write zero on it, which will appear blank on the board. 

Throughout the entire game, the original board is not changed, all the changes happen in the usrboard Sudoku board. This is because if the user is filling the value and it alters the original board, then the computer wouldn't be able to figure out which block is removeable and which one is not. If the user accidentally removed a default block that is not supposed to be removeable, that could drastically change the outcome of the game and maybe even making the computer unable to solve it. With the user being able to get a different answer if they alter the original board, this should be totally avoided.
# The Solver Algorithm
### WARNING!!! This solver is not the final solver, it can only solve relatively easy Sudoku with only 1 solution possible!!!!!!
The solver plays a crucial role in the game, it will give the user solution really quickly whenever they give up on trying to solve the puzzle. 

First, there are several helper methods to assist the solver to be able to solve the puzzle. The helper methods helps to analyze the entire Sudoku and put all the possible values into a single matrix. 

The first helper method is analyzeRow(), which analyze a specific row to find which numbers can be filled in. The number that is able to fill in will be located at the index that is represented by the number - 1, and then stored into a 2D array that store all the information of every row of what can be filled in. Same thing applies for analyzeCol() but instead all the rows are replaced by columns and columns are replaced by rows. The third method, analyzeCell() is a little different, it basically does the exact same thing but instead of using a 2D array it uses a 3D array that is 3x3x9. It ultimately does the same thing than the previous methods.
